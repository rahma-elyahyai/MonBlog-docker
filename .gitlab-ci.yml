stages:
  - build
  - test
  - push

variables:
  DOCKER_TLS_CERTDIR: ""
  DOCKER_DRIVER: overlay2

default:
  image: docker:27
  services:
    - name: docker:27-dind
  before_script:
    - docker info
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"

# 1) Build image web
build_web:
  stage: build
  script:
    - docker build -t "$CI_REGISTRY_IMAGE/web:$CI_COMMIT_SHORT_SHA" .
  rules:
    - if: $CI_COMMIT_BRANCH

# 2) Integration test: docker compose up + check HTTP + check DB
integration_test:
  stage: test
  script:
    - docker compose version

    # Evite conflits de ports en CI (override à la volée)
    - |
      cat > docker-compose.ci.yml <<'EOF'
      services:
        web:
          ports: []
        db:
          ports: []
      EOF

    - docker compose -f docker-compose.yml -f docker-compose.ci.yml up -d --build
    - docker compose ps
    - docker compose logs --no-color --tail=100 db || true
    - docker compose logs --no-color --tail=100 web || true

    # DB check
    - docker exec monblog-db mysql -uroot -proot -e "SHOW DATABASES;"

    # HTTP check depuis le conteneur web
    - docker exec monblog-web curl -fsS http://localhost/ >/dev/null
  after_script:
    - docker compose -f docker-compose.yml -f docker-compose.ci.yml down -v
  rules:
    - if: $CI_COMMIT_BRANCH

# 3) Push image au GitLab Container Registry
push_web:
  stage: push
  needs: ["build_web", "integration_test"]
  script:
    - docker build -t "$CI_REGISTRY_IMAGE/web:$CI_COMMIT_SHORT_SHA" .
    - docker push "$CI_REGISTRY_IMAGE/web:$CI_COMMIT_SHORT_SHA"

    # Tag latest uniquement sur main
    - |
      if [ "$CI_COMMIT_BRANCH" = "main" ]; then
        docker tag "$CI_REGISTRY_IMAGE/web:$CI_COMMIT_SHORT_SHA" "$CI_REGISTRY_IMAGE/web:latest"
        docker push "$CI_REGISTRY_IMAGE/web:latest"
      fi
  rules:
    - if: $CI_COMMIT_BRANCH
